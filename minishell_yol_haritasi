SORU : ben branch ile ilgili hicbir sey bilmiyorum. bu zamana kadar hep main branch kullandim. bana ona gore anlat.

TuÄŸra, bugÃ¼ne kadar hep tek baÅŸÄ±na veya aynÄ± dosya Ã¼zerinden gittiÄŸin iÃ§in main dÄ±ÅŸÄ±nda bir ÅŸeye ihtiyaÃ§ duymaman Ã§ok normal. Ama ÅŸu an Zeynep ile "Ã‡arpÄ±ÅŸmamak" iÃ§in branÅŸlar senin en yakÄ±n dostun olacak.

ÅÃ¶yle dÃ¼ÅŸÃ¼n: BugÃ¼ne kadar hep tek bir deftere sÄ±rayla yazÄ± yazdÄ±nÄ±z. Biri yazarken diÄŸeri beklemek zorundaydÄ± ya da aynÄ± anda yazÄ±nca yazÄ±lar birbirine giriyordu.

BranÅŸ kullanmak ise ÅŸudur:

ğŸ“– 1. Fotokopi MantÄ±ÄŸÄ± (En Basit AnlatÄ±m)
Åu an elinizde projenin ana dosyalarÄ± var (main branch).

BranÅŸ AÃ§mak: Projenin o anki halinin birebir fotokopisini Ã§ekip kendine Ã¶zel bir klasÃ¶re koymak gibidir.

BaÄŸÄ±msÄ±zlÄ±k: Sen kendi fotokopin Ã¼zerinde src/executor/ klasÃ¶rÃ¼ne istediÄŸini yazarsÄ±n, silersin, dosyalarÄ± karÄ±ÅŸtÄ±rÄ±rsÄ±n. Ana dosya (main) asla deÄŸiÅŸmez.

GÃ¶rÃ¼nmezlik: Zeynep senin o kaÄŸÄ±da ne karaladÄ±ÄŸÄ±nÄ± gÃ¶rmez. O da kendi fotokopisi Ã¼zerinde src/parser/ ile uÄŸraÅŸÄ±r.

ğŸ“‚ 2. BilgisayarÄ±nda Fiziksel Olarak Ne Oluyor?
BurasÄ± en ilginÃ§ kÄ±sÄ±m. Git, senin klasÃ¶rÃ¼nÃ¼ o an hangi branÅŸtaysan ona gÃ¶re "anÄ±nda" dÃ¼zenler.

Sen feature/executor branÅŸÄ±ndayken ls yaparsÄ±n, kendi yazdÄ±ÄŸÄ±n dosyalarÄ± gÃ¶rÃ¼rsÃ¼n.

Terminalden git checkout main (ana branÅŸa geÃ§) dediÄŸin an, gÃ¶zÃ¼nÃ¼n Ã¶nÃ¼nde o az Ã¶nce yazdÄ±ÄŸÄ±n dosyalar klasÃ¶rden kaybolur! Ã‡Ã¼nkÃ¼ main branÅŸÄ±nda o dosyalar henÃ¼z yok.

Tekrar kendi branÅŸÄ±na geÃ§tiÄŸinde dosyalarÄ±n geri gelir.

Yani branÅŸlar, aynÄ± klasÃ¶rÃ¼n iÃ§indeki "farklÄ± boyutlar" gibidir.

ğŸ–‡ï¸ 3. Ä°ÅŸler NasÄ±l BirleÅŸiyor? (The Merge)
Diyelim ki akÅŸam oldu. Sen executor'Ä± bitirdin, Zeynep de parser'Ä±. ArtÄ±k bunlarÄ± birleÅŸtirip "gerÃ§ek proje" haline getirme vakti:

Sen kendi fotokopini (branÅŸÄ±nÄ±) GitHub'a gÃ¶nderirsin.

Zeynep de kendininkini gÃ¶nderir.

GitHub Ã¼zerinden "Merge" (BirleÅŸtir) dediÄŸinizde; Git, senin eklediÄŸin dosyalarÄ± ve Zeynep'in eklediÄŸi dosyalarÄ± alÄ±r, ikisini de ana dosyaya (main) ekler.

SonuÃ§: ArtÄ±k main branch'inde hem senin kodlarÄ±n hem Zeynep'inkiler tertemiz durur.

ğŸ› ï¸ 4. Senin Ä°Ã§in "AdÄ±m AdÄ±m" Uygulama
YarÄ±n Cluster'a gittiÄŸinde terminale ÅŸu 3-4 komutu yazman yeterli. BaÅŸka hiÃ§bir ÅŸeye ihtiyacÄ±n yok:

1. Kendi branÅŸÄ±nÄ± oluÅŸtur (Sadece bir kez yapacaksÄ±n):

Bash
git checkout -b tugra_exec
(ArtÄ±k "tugra_exec" boyutundasÄ±n. Ä°stediÄŸini yapabilirsin.)

2. KodlarÄ±nÄ± yazdÄ±n, bitti. BunlarÄ± kendi boyutuna kaydet:

Bash
git add .
git commit -m "Executor dosyalari eklendi"
3. Kendi boyutunu internete (GitHub'a) yÃ¼kle:

Bash
git push origin tugra_exec
4. Zeynep'in yaptÄ±klarÄ±nÄ± gÃ¶rmek istersen: Ana branÅŸa geÃ§ip (git checkout main) oradan git pull yapman yeterli. Ama bunu sadece birleÅŸtirme yapacaÄŸÄ±nÄ±z zaman yapacaksÄ±nÄ±z.
--------------------------------------------------------------------------------------------------------------------
SORU : ertesi gun tekrar mi yeni branch olusturacagiz mesela mege ettik isimiz bitti ben tekrar zeynebin de ekledigi yeni dosyalarla birlikte calisabilmek icin tekrar mi brach olustracaz?

Hayat planlama botu
Ã–zel Gem
Hah, iÅŸte kilit soru bu! Ä°ÅŸin "sÃ¼reklilik" sÄ±rrÄ±nÄ± soruyorsun. Her gÃ¼n yeni bir branch oluÅŸturmana gerek yok ama her gÃ¼n "paralel evrenini gÃ¼ncellemen" gerekiyor.

Zeynep'in eklediÄŸi dosyalarÄ± kendi bilgisayarÄ±nda ve kendi Ã§alÄ±ÅŸma alanÄ±nda gÃ¶rebilmen iÃ§in izlemen gereken "Sabah Rutini" tam olarak ÅŸudur:

ğŸ”„ Git "Sabah Åerifleri" Rutini (GÃ¼ncelleme DÃ¶ngÃ¼sÃ¼)
Diyelim ki akÅŸam her ÅŸeyi main'de birleÅŸtirdiniz ve eve gittiniz. Ertesi sabah Cluster'a oturdun:

Ana Kampa Git: Ã–nce ana dosyalarÄ±n olduÄŸu yere geÃ§.

Bash
git checkout main
Ganimetleri Topla: GitHub'daki (Zeynep'in de iÃ§inde olduÄŸu) en son halini bilgisayarÄ±na Ã§ek.

Bash
git pull origin main
ArtÄ±k senin bilgisayarÄ±ndaki main branch'inde Zeynep'in dosyalarÄ± da var!

Kendi Evrenine DÃ¶n: Kendi Ã§alÄ±ÅŸtÄ±ÄŸÄ±n branch'e geri git.

Bash
git checkout tugra_exec
Zeynep'in DosyalarÄ±nÄ± Kendi DÃ¼nyana Kat: Ä°ÅŸte sihirli komut bu. main'deki (Zeynep'in dosyalarÄ±nÄ± iÃ§eren) yenilikleri kendi branch'ine kopyala.

Bash
git merge main
ğŸ¤” "Yeni Branch mÄ±, Eski Branch mÄ±?"
AslÄ±nda iki seÃ§eneÄŸin var:

SeÃ§enek A (Devam Etmek): YukarÄ±daki gibi git merge main yaparak eski branch'inden devam edersin. (Daha kolaydÄ±r, geÃ§miÅŸini kaybetmezsin).

SeÃ§enek B (Taze BaÅŸlangÄ±Ã§): Eski branch'ini silip, main'den yepyeni bir tane aÃ§arsÄ±n:

Bash
git branch -D tugra_exec       # Eskiyi sil
git checkout -b tugra_exec_v2  # Yeniyi aÃ§
Profesyoneller genelde her yeni "kÃ¼Ã§Ã¼k Ã¶zellik" iÃ§in yeni bir branch aÃ§ar ama Minishell gibi 20 gÃ¼nlÃ¼k maratonda tek bir tugra_exec branch'ini gÃ¼ncel tutarak gitmek kafanÄ± daha az karÄ±ÅŸtÄ±rÄ±r.

âš ï¸ BirleÅŸme SonrasÄ± "DosyalarÄ±m Gitti mi?" Korkusu
HayÄ±r, gitmez! git merge main yaptÄ±ÄŸÄ±nda Git ÅŸuna bakar:

"TuÄŸra executor/ klasÃ¶rÃ¼nde 2 dosya deÄŸiÅŸtirmiÅŸ."

"Zeynep parser/ klasÃ¶rÃ¼ne 3 dosya eklemiÅŸ."

SonuÃ§: Git, Zeynep'in dosyalarÄ±nÄ± senin klasÃ¶rÃ¼ne getirir ama senin yazdÄ±klarÄ±na dokunmaz. Ä°kisi birleÅŸmiÅŸ olur.

-----------------------------------------------------------------------------------------------------------------

Soru : Tamam biz dongu olarak ne yapacagiz ? TuÄŸra, her ÅŸey hazÄ±r. KlasÃ¶rleri kurdun, Zeynep'le el sÄ±kÄ±ÅŸtÄ±n. Åimdi bu iÅŸin *"Kusursuz DÃ¶ngÃ¼sÃ¼"*ne giriyoruz. Bu dÃ¶ngÃ¼ye sadÄ±k kalÄ±rsanÄ±z, 16 Åubat'ta o projeyi teslim ederken "Dosyam silindi, kodlar karÄ±ÅŸtÄ±" diye bir cÃ¼mleniz asla olmayacak. ğŸ›¡ï¸

Ä°ÅŸte yarÄ±ndan itibaren her gÃ¼n uygulayacaÄŸÄ±n "Minishell YaÅŸam DÃ¶ngÃ¼sÃ¼":

â˜€ï¸ 1. Sabah: "Karakolu GÃ¼ncelleme" (Morning Routine)
Cluster'a oturdun, kahveni aldÄ±n. Ä°lk yapacaÄŸÄ±n ÅŸey dÃ¼nyadan haber almak:

Ana kampa git: git checkout main

Zeynep'in gece attÄ±klarÄ±nÄ± Ã§ek: git pull origin main

Kendi dÃ¼nyana dÃ¶n: git checkout tugra_exec (EÄŸer branch yoksa: git checkout -b tugra_exec)

Zeynep'in yeniliklerini kendi koduna yedir: git merge main

ğŸ’» 2. GÃ¼n Boyu: "SavaÅŸ AlanÄ±" (Coding Phase)
Bu aÅŸamada sadece kendi klasÃ¶rÃ¼nde (src/executor/) ve branÅŸÄ±nda (tugra_exec) takÄ±l:

Kodunu yaz.

Testlerini yap.

Arada bir "kayÄ±t noktasÄ±" al:

git add .

git commit -m "Executor: Pipe dongusu kuruldu"

ğŸŒ™ 3. AkÅŸam: "Ganimetleri BirleÅŸtirme" (Evening/Task Done)
Ä°ÅŸin bitti veya gÃ¼n sona erdi. Kodunu ana kampa (main) gÃ¶nderme vakti:

Kodunu buluta yolla: git push origin tugra_exec

GitHub'a gir: Orada sarÄ± bir kutu gÃ¶receksin: "Compare & Pull Request". Ona bas.

Merge Et: Zeynep'le yan yana bakÄ±n, "Hata yok" derseniz "Confirm Merge" yapÄ±n.

ArtÄ±k senin yaptÄ±ÄŸÄ±n her ÅŸey main branch'ine geÃ§ti!

ğŸ”„ Bu DÃ¶ngÃ¼nÃ¼n GÃ¶rsel Ã–zeti
âš ï¸ Asla Yapmaman Gereken "3 BÃ¼yÃ¼k GÃ¼nah"
main branch'inde kod yazma: OrasÄ± sizin "kutsal" ve Ã§alÄ±ÅŸan kod alanÄ±nÄ±z. Sadece birleÅŸmiÅŸ kodlar orada durmalÄ±.

git push --force kullanma: Bu komut arkadaÅŸÄ±nÄ±n kodlarÄ±nÄ± silebilir. Asla zorlama!

KonuÅŸmadan Merge yapma: BÃ¼yÃ¼k bir deÄŸiÅŸikliÄŸi main'e atmadan Ã¶nce Zeynep'e "Kanka ben header'Ä± deÄŸiÅŸtirdim, haberin olsun" de.
-----------------------------------------------------------------------------------------------------------------
Soru : ya zeynep ile ayni saatte calisiyorsak ve o henuz daha yeni degisikli kyapmisken ben onun mergini gormeyip yani guncel versiyonu kendi koduma gecemeyip eski versiyon uzerinde degisiklikler yaptiysam ? o zaman ne olacak ?

TuÄŸra, korkma! Ä°ÅŸte Git'in "bÃ¼yÃ¼cÃ¼" olduÄŸu asÄ±l an burasÄ±. Bu durum yazÄ±lÄ±m dÃ¼nyasÄ±nda her saniye yaÅŸanÄ±yor ve Ã§Ã¶zÃ¼mÃ¼ Ã§ok basit. HiÃ§bir ÅŸey silinmez, hiÃ§bir ÅŸey kaybolmaz.

Senin durumunu bir "Ev ArkadaÅŸlÄ±ÄŸÄ±" Ã¼zerinden anlatalÄ±m:

ğŸ  Mutfak ve Salon Analojisi
DÃ¼ÅŸÃ¼n ki ikiniz aynÄ± evin (projenin) iÃ§inde Ã§alÄ±ÅŸÄ±yorsunuz.

Zeynep: Mutfaktaki (parser klasÃ¶rÃ¼) dolaplarÄ± boyadÄ± ve "Ben iÅŸimi bitirdim" diyerek anahtarÄ± merkeze (main) bÄ±raktÄ±.

Sen: O sÄ±rada salonda (executor klasÃ¶rÃ¼) televizyon Ã¼nitesi kuruyordun. Zeynep'in mutfaÄŸÄ± boyadÄ±ÄŸÄ±ndan haberin yok, sen hala evin "eski boyalÄ±" halindeki salonda Ã§alÄ±ÅŸÄ±yorsun.

SonuÃ§ ne olur? Sen iÅŸini bitirip "Benim salon hazÄ±r" dediÄŸinde, Git gelir ve der ki: "Tamam TuÄŸra, senin yeni salonunu alÄ±yorum, Zeynep'in yeni mutfaÄŸÄ±nÄ± da alÄ±yorum; ikisini birleÅŸtirip harika bir ev yapÄ±yorum."

ğŸ›¡ï¸ Git Bu Durumu NasÄ±l Engeller? (The Safety Lock)
Sen eski versiyon Ã¼zerindeyken kodunu GitHub'a gÃ¶ndermeye (push) Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda, GitHub sana kÄ±rmÄ±zÄ± bir uyarÄ± verir:

"Hata! Senin versiyonun eski. Ã–nce arkadaÅŸÄ±nÄ±n yaptÄ±klarÄ±nÄ± al, sonra kendi yaptÄ±klarÄ±nÄ± gÃ¶nder."

GitHub seni durdurur, yani Zeynep'in kodunun Ã¼stÃ¼ne yanlÄ±ÅŸlÄ±kla yazamazsÄ±n. Sistem buna izin vermez.

ğŸ› ï¸ Bu Durumda Ne YapacaksÄ±n? (Kurtarma Operasyonu)
Diyelim ki 3 saattir Ã§alÄ±ÅŸÄ±yorsun ve Zeynep'in main'e bir ÅŸeyler attÄ±ÄŸÄ±nÄ± fark ettin. Hemen ÅŸu sÄ±rayÄ± izle:

Kendi Ä°ÅŸini Kaydet: (YarÄ±m kalsa bile commit at, kaybolmasÄ±n)

Bash
git add .
git commit -m "Executor uzerinde calismaya devam"
Zeynep'in Yeniliklerini Al:

Bash
git checkout main
git pull origin main
Kendi DÃ¼nyana Zeynep'i Davet Et:

Bash
git checkout tugra_exec
git merge main
O an ne olur? Git, senin 3 saatlik emeÄŸinle Zeynep'in yeni attÄ±ÄŸÄ± kodlarÄ± "ÅŸak" diye birleÅŸtirir. Sen farklÄ± klasÃ¶rde (executor), o farklÄ± klasÃ¶rde (parser) olduÄŸu iÃ§in Git hiÃ§bir hata vermeden ikisini de aynÄ± klasÃ¶re koyar.

